#' Create a univariate distribution sampler
#'
#' Generate a function which generates samples from the distribution given the inverse and
#' collocation points.
#'
#' The univariate_sampler function is used for generating unconditional distributions using SCMC
#' with 1-D interpolation, whereas the conditional_sampler enables generating samples from random
#' varaibles which are conditioned on other variables. The inverse_cdf function in the conditional
#' case must take k+1 arguments, where k is the number of conditions, and return the inverse cdf for
#' the variable Y|X_1, ..., X_k, taking the arguments in order: (X_1, ..., X_k, p), where p is from
#' (0,1). For example, if we sample Y|X, we have a function \eqn{invcdf(x, p) = F^{-1}_{Y|X=x}(p).}
#'
#' Using the compile_c flag requires Rcpp and compiles the funtion that evaluates the polynomial
#' used in sampling to C code. This results in about 4-5 times increase in speed of evaluation, but
#' takes some time to compile.
#'
#' @param inverse_cdf The inverse cdf (i.e. quantile) function of the distribution to be sampled.
#' @param col_pts The collocation points to use for interpolation (usually generated by
#'   scmc::optimal_points()).
#' @param gss The sigma value of the approximating normal variable if using grid stretching.
#' @param compile_c Logical indicating whether to compile the resulting sampling function as C code.
#' @return \itemize{ \item For univariate_sampler, a function which takes a single argument n, and
#'   generates a sample of size n from the wanted distribution. \item For conditional_sampler, a
#'   function which takes two arguments: \itemize{ \item n - the size of the sample to generate
#'   \item conditional_samples - a list of samples of size n which are generated from the
#'   distributions on which the wanted distribution is conditioned. The list should follow the order
#'   as in inverse_cdf function} }
#' @export
univariate_sampler <- function(inverse_cdf, col_pts, xdist = "norm", gss = 1, compile_c = FALSE) {
  if (xdist == "norm") {
    poly <- lagrange(function(x) inverse_cdf(pnorm(x, sd = gss)), col_pts, compile_c = compile_c)

    function(n) {
      poly(rnorm(n, sd = gss))
    }
  } else {
    xcdf <- match.fun(paste0("p", xdist))
    poly <- lagrange(function(x) inverse_cdf(xcdf(x)), col_pts, compile_c = compile_c)

    xrand <- match.fun(paste0("r", xdist))
    function(n) {
      poly(xrand(n))
    }
  }
}


#' @rdname univariate_sampler
#' @export
conditional_sampler <- function(inverse_cdf, col_pts, gss = 1, compile_c = FALSE) {
  poly <- lagrange(col_pts = col_pts, FUN = function(...) {
    args <- list(...)
    n <- length(args)
    do.call(inverse_cdf, c(args[-n], list(pnorm(args[[n]], sd = gss))))
  }, compile_c = compile_c)

  function(n, condition_samples = list()) {
    do.call(poly, c(condition_samples, list(rnorm(n, sd = gss))))
  }
}