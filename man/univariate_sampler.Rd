% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/univariate.R
\name{univariate_sampler}
\alias{univariate_sampler}
\alias{conditional_sampler}
\title{Create a univariate distribution sampler}
\usage{
univariate_sampler(inverse_cdf, col_pts, gss = 1, compile_c = FALSE)

conditional_sampler(inverse_cdf, col_pts, gss = 1, compile_c = FALSE)
}
\arguments{
\item{inverse_cdf}{The inverse cdf (i.e. quantile) function of the distribution to be sampled.}

\item{col_pts}{The collocation points to use for interpolation (usually generated by
scmc::optimal_points()).}

\item{gss}{The sigma value of the approximating normal variable if using grid stretching.}

\item{compile_c}{Logical indicating whether to compile the resulting sampling function as C code.}
}
\value{
\itemize{ \item For univariate_sampler, a function which takes a single argument n, and
  generates a sample of size n from the wanted distribution. \item For conditional_sampler, a
  function which takes two arguments: \itemize{ \item n - the size of the sample to generate
  \item conditional_samples - a list of samples of size n which are generated from the
  distributions on which the wanted distribution is conditioned. The list should follow the order
  as in inverse_cdf function} }
}
\description{
Generate a function which generates samples from the distribution given the inverse and
collocation points.
}
\details{
The univariate_sampler function is used for generating unconditional distributions using SCMC
with 1-D interpolation, whereas the conditional_sampler enables generating samples from random
varaibles which are conditioned on other variables. The inverse_cdf function in the conditional
case must take k+1 arguments, where k is the number of conditions, and return the inverse cdf for
the variable Y|X_1, ..., X_k, taking the arguments in order: (X_1, ..., X_k, p), where p is from
(0,1). For example, if we sample Y|X, we have a function \eqn{invcdf(x, p) = F^{-1}_{Y|X=x}(p).}

Using the compile_c flag requires Rcpp and compiles the funtion that evaluates the polynomial
used in sampling to C code. This results in about 4-5 times increase in speed of evaluation, but
takes some time to compile.
}
